# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l52lNIO04u9VdjGiLxPjGj_YeS0DHn0L
"""

import streamlit as st
from pytube import YouTube
from moviepy.editor import *
import speech_recognition as sr
import requests
import csv
import os
import io
import nltk
from pydub import AudioSegment
from nltk.tokenize import word_tokenize
from nltk.corpus import stopwords

def download_audio(youtube_link):
    try:
        # Extract the YouTube video's audio
        video = YouTube(youtube_link)
        audio = video.streams.filter(only_audio=True).first()
        audio_streams = video.streams.filter(only_audio=True)
        audio_streams = sorted(audio_streams, key=lambda s: s.bitrate)
        audio = audio_streams[0]

        # Download the audio
        st.write("Downloading audio...")
        audio_filename = "my_audio.mp3"
        audio.download(filename=audio_filename)
        st.success("Audio downloaded successfully!")

        return audio_filename

    except Exception as e:
        st.error(f"An error occurred during audio download: {str(e)}")



def process_audio(audio_filename):
    try:
        # Convert audio to text
        st.write("Converting audio to text...")
        audio_path = f"./{audio_filename}.wav"
        audio_clip = AudioFileClip(audio_filename)
        audio_clip.write_audiofile(audio_path)

        # Perform speech recognition
        r = sr.Recognizer()

        with sr.AudioFile(audio_path) as source:
           audio_data = r.record(source)
        #text = r.recognize_google(audio_data)
        text = r.recognize_sphinx(audio_data)

        st.success("Audio converted to text successfully!")
        st.write("Text:")
        #st.write(text1)
        st.write(text)

        # Save the text as a text file
        text_file_path = "./audio.txt"
        with open(text_file_path, "w") as text_file:
            text_file.write(text)
        st.success("Text saved successfully as a text file!")

        # Perform forced alignment with Gentle
        st.write("Performing forced alignment...")

        # Prepare the data for the Gentle API request
        gentle_url = "http://localhost:8888/transcriptions?async=false"
        files = {"audio": open(audio_path, "rb")}
        data = {"transcript": text}

        # Send the request to the Gentle server
        response = requests.post(gentle_url, files=files, data=data)

        if response.status_code == 200:
            alignment_data = response.json()

            # Save the alignment result as CSV
            csv_path = "./alignment_result.csv"
            with open(csv_path, "w", newline="") as csv_file:
                writer = csv.writer(csv_file)
                writer.writerow(["word", "start", "end"])
                for word in alignment_data["words"]:
                    if "start" in word:
                        start_time = word["start"]
                    elif "startOffset" in word:
                        start_time = word["startOffset"] / 1000
                    else:
                        start_time = ""

                    if "end" in word:
                        end_time = word["end"]
                    elif "endOffset" in word:
                        end_time = word["endOffset"] / 1000
                    else:
                        end_time = ""

                    writer.writerow([word["word"], start_time, end_time])

            st.write("Forced alignment result saved as CSV.")

        else:
            st.error("Failed to perform forced alignment.")

    except Exception as e:
        st.error(f"An error occurred during audio processing: {str(e)}")

stop_words = set(stopwords.words('english'))
#nltk.download('punkt')
#nltk.download('stopwords')

def search_word(csv_file_path, search_input):
    search_results = []
    temp_file = 'temp.csv'
    with open(csv_file_path, 'r') as file_in, open(temp_file, 'w', newline='') as file_out:
        reader = csv.reader(file_in)
        writer = csv.writer(file_out)

        for row in reader:
            words = word_tokenize(row[0])  # Tokenize the words in the first column

            # Check if any word in the row is a connector word
            if any(word in stop_words for word in words):
                continue  # Skip the row if it contains a connector word

            # Write the row to the temporary CSV file
            writer.writerow(row)

    # Replace the original CSV file with the modified output
    os.replace(temp_file, csv_file_path)
    search_words = search_input.split()
    with open(csv_file_path, "r") as csv_file:
        reader =list(csv.reader(csv_file))
        #next(reader)  # Skip the header row
          #for i in length(search_words):
        for i, row in enumerate(reader):
             if row[0] == search_words[0]:
               if len(search_words) == 1:
                 search_results.append(row)
               elif i + 1 < len(reader):  # Ensure there is a next row
                  next_row = reader[i + 1]
                  if len(search_words) > 1 and next_row[0] == search_words[1]:
                    search_results.append(row)
    return search_results

def delete_files(file_paths):
    for file_path in file_paths:
        try:
            os.remove(file_path)
        except OSError as e:
            st.error(f"Error deleting file '{file_path}': {str(e)}")

def main():
    st.title("VANS AUDIO SYSTEM")
    #warm_up_speech_recognition()
    #sr.speech_recognition.start()
    r = sr.Recognizer()

    # Select audio source option
    audio_source = st.radio("Select audio source", ("Audio Upload", "YouTube Link"))

    if audio_source == "Audio Upload":
        # Audio upload option
        uploaded_file = st.file_uploader("Upload Audio", type=["mp3", "wav"])

        # Process uploaded audio if button is clicked
        if st.button("Process Audio") and uploaded_file is not None:
            # Save the uploaded audio file with the desired filename
            audio_filename = "my_audio.mp3"  # Rename the file as desired

            with open(audio_filename, "wb") as f:
                f.write(uploaded_file.read())

            st.success("Audio uploaded successfully!")
            process_audio(audio_filename)

    elif audio_source == "YouTube Link":
        # YouTube link option
        youtube_link = st.text_input("Enter YouTube link")

        # Process YouTube audio if button is clicked
        if st.button("Process Audio"):
            audio_filename = download_audio(youtube_link)

            # Check if audio download was successful before proceeding
            if audio_filename:
                process_audio(audio_filename)
    text_file_path = "./audio.txt"
    # Open the file and read its contents
    with open(text_file_path, "r") as file:
        text = file.read()
    st.write(text)
    # Display the audio bar
    audio_file_path = "./my_audio.mp3"
    audio_bytes = open(audio_file_path, "rb").read()
    st.audio(audio_bytes, format="audio/mp3")
    #generated_text= process_audio(audio_filename)
    #st.write(generated_text)
    # Input field for the search word
    search_input = st.text_input("Enter word to search")
    selected_option = None
    csv_file_path = "./alignment_result.csv"
    search_results = search_word(csv_file_path, search_input)
    search_results_messages = []
    # Search button
    if st.button("Search"):
        if search_results:

            st.write("Search results:")
            search_results_messages = []
            for i, result in enumerate(search_results):
                #word = result[0]
                word = search_input
                start_time = float(result[1])
                option = i + 1
                #st.markdown(f"Option {option}: Word '{word}' found at t={start_time}s")
                message= f"Option {option}: Word '{word}' found at t={start_time}s"
                search_results_messages.append(message)
        else:
            st.write("No results found.")
    for message in search_results_messages:
        st.markdown(message)

    if search_results:
        max_value = len(search_results)
    else:
        max_value = 1
    selected_option = st.number_input("Enter the option to seek", min_value=1, max_value=max_value, step=1, value=1, key='seek_option')
    # Seek functionality
    if st.button("Seek"):
        if selected_option:
            selected_result = search_results[selected_option - 1]
            word = selected_result[0]
            start_time = float(selected_result[1])
            modify_audio(start_time)
    if st.button("Done"):
        delete_files(["my_audio.mp3", "audio.txt", "alignment_result.csv"])

        st.write("All files deleted successfully!")


def modify_audio(start_time):
    # Convert audio file to audio segment
    audio = AudioSegment.from_file("./my_audio.mp3")
    # Calculate total duration in seconds
    total_duration = len(audio) / 1000

    # Seek to the desired time
    new_audio = audio[int(start_time * 1000):]

    # Convert seeked audio segment to byte array
    new_audio_bytes = new_audio.export(format="wav").read()

    # Display the audio player with seeked audio
    st.audio(io.BytesIO(new_audio_bytes), format='audio/wav')


if __name__ == "__main__":
    main()